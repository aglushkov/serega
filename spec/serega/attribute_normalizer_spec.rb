# frozen_string_literal: true

RSpec.describe Serega::SeregaAttributeNormalizer do
  let(:serializer_class) { Class.new(Serega) }
  let(:normalizer) { serializer_class::SeregaAttributeNormalizer }

  describe "#name" do
    it "symbolizes name" do
      attribute = normalizer.new(name: "current_name")
      expect(attribute.name).to eq :current_name
    end
  end

  describe "#method_name" do
    it "returns symbolized :method options" do
      attribute = normalizer.new(name: "current_name", opts: {method: "method"})
      expect(attribute.method_name).to eq :method
    end

    it "returns name when :method option not provided" do
      attribute = normalizer.new(name: "current_name", opts: {})
      expect(attribute.method_name).to eq :current_name
    end
  end

  describe "#many" do
    it "returns provided :many option" do
      expect(normalizer.new(opts: {many: true}).many).to be true
      expect(normalizer.new(opts: {many: false}).many).to be false
      expect(normalizer.new(opts: {}).many).to be_nil
    end

    it "returns saved :many option" do
      norm = normalizer.new(opts: {many: true})

      expect(norm.many).to be true
      expect(norm.instance_variable_get(:@many)).to be true

      norm.instance_variable_set(:@many, nil)
      expect(norm.many).to be_nil
    end
  end

  describe "#hide" do
    it "returns provided :hide option" do
      expect(normalizer.new(opts: {hide: true}).hide).to be true
      expect(normalizer.new(opts: {hide: false}).hide).to be false
      expect(normalizer.new(opts: {}).hide).to be_nil
    end

    it "returns saved :hide option" do
      norm = normalizer.new(opts: {hide: true})

      expect(norm.hide).to be true
      expect(norm.instance_variable_get(:@hide)).to be true

      norm.instance_variable_set(:@hide, nil)
      expect(norm.hide).to be_nil
    end
  end

  describe "#serializer" do
    it "returns provided :serializer option" do
      expect(normalizer.new(opts: {serializer: 123}).serializer).to eq 123
    end

    it "returns saved :serializer option" do
      norm = normalizer.new(opts: {serializer: true})

      expect(norm.serializer).to be true
      expect(norm.instance_variable_get(:@serializer)).to be true

      norm.instance_variable_set(:@serializer, nil)
      expect(norm.serializer).to be_nil
    end
  end

  describe "#prepare_value_block" do
    it "returns provided block" do
      block = proc {}
      attribute = normalizer.new(block: block)
      expect(attribute.send(:prepare_value_block)).to eq block
    end

    it "returns normalized provided block if it accepts only 1 argument" do
      block = lambda { |a| a }
      attribute = normalizer.new(block: block)
      value_block = attribute.send(:prepare_value_block)
      expect(value_block).not_to eq block
      expect(value_block.call(1, 2)).to eq 1
    end

    it "returns block generated by :method option" do
      block = normalizer.new(opts: {method: :length}).send(:prepare_value_block)
      expect(block).to be_a Proc
      expect(block.call(double(length: 3))).to eq 3
    end

    it "returns block generated by :value option" do
      value = proc {}
      block = normalizer.new(opts: {value: value}).send(:prepare_value_block)
      expect(block).to be value
    end

    it "returns provided value if it has 2 parameters" do
      value = proc { |one, two| }
      attribute = normalizer.new(opts: {value: value})
      expect(attribute.send(:prepare_value_block)).to equal value
    end

    it "moodifies provided value to accept two parameters if only one is originally accepted" do
      value = lambda { |one| one }
      attribute = normalizer.new(opts: {value: value})
      value_block = attribute.send(:prepare_value_block)
      expect(value_block).not_to equal value
      expect(value_block.call(1)).to equal 1
    end

    it "returns block generated by :const option" do
      const = "123"
      block = normalizer.new(opts: {const: const}).send(:prepare_value_block)
      expect(block).to be_a Proc
      expect(block.call).to be const
    end

    it "returns block generated by :delegate option when nil is not allowed" do
      object = double(foo: double(name: "DELEGATED_NAME"))
      delegate = {to: :foo}
      block = normalizer.new(name: :name, opts: {delegate: delegate}).send(:prepare_value_block)
      expect(block).to be_a Proc
      expect(block.call(object)).to eq "DELEGATED_NAME"
    end

    it "returns block generated by :delegate option that uses :method option" do
      object = double(foo: double(bar: "DELEGATED_NAME"))
      delegate = {to: :foo, method: :bar}
      block = normalizer.new(opts: {delegate: delegate}).send(:prepare_value_block)
      expect(block).to be_a Proc
      expect(block.call(object)).to eq "DELEGATED_NAME"
    end

    it "does not raise error when :delegating object is nil and nil is allowed" do
      object1 = double(foo: nil)
      object2 = double(foo: double(name: "NAME"))
      delegate = {to: :foo, allow_nil: true}
      block = normalizer.new(name: :name, opts: {delegate: delegate}).send(:prepare_value_block)
      expect(block).to be_a Proc
      expect(block.call(object1)).to be_nil
      expect(block.call(object2)).to eq "NAME"
    end

    it "does not raise error when :delegating object is nil and nil is allowed through config" do
      object1 = double(foo: nil)
      object2 = double(foo: double(name: "NAME"))
      delegate = {to: :foo}
      serializer_class.config.delegate_default_allow_nil = true
      block = normalizer.new(name: :name, opts: {delegate: delegate}).send(:prepare_value_block)
      expect(block).to be_a Proc
      expect(block.call(object1)).to be_nil
      expect(block.call(object2)).to eq "NAME"
    end
  end
end

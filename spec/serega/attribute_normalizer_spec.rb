# frozen_string_literal: true

RSpec.describe Serega::SeregaAttributeNormalizer do
  let(:serializer_class) { Class.new(Serega) }
  let(:normalizer) { serializer_class::SeregaAttributeNormalizer }

  describe "#name" do
    it "symbolizes name" do
      attribute = normalizer.new(name: "current_name")
      expect(attribute.name).to eq :current_name
    end
  end

  describe "#method_name" do
    it "returns symbolized :method options" do
      attribute = normalizer.new(name: "current_name", opts: {method: "method"})
      expect(attribute.method_name).to eq :method
    end

    it "returns name when :method option not provided" do
      attribute = normalizer.new(name: "current_name", opts: {})
      expect(attribute.method_name).to eq :current_name
    end
  end

  describe "#many" do
    it "returns provided :many option" do
      expect(normalizer.new(opts: {many: true}).many).to be true
      expect(normalizer.new(opts: {many: false}).many).to be false
      expect(normalizer.new(opts: {}).many).to be_nil
    end

    it "returns saved :many option" do
      norm = normalizer.new(opts: {many: true})
      expect(norm.many).to be true
      expect(norm.instance_variable_get(:@many)).to be true

      norm.instance_variable_set(:@many, nil)
      expect(norm.many).to be_nil
    end
  end

  describe "#hide" do
    it "returns provided :hide option" do
      expect(normalizer.new(opts: {hide: true}).hide).to be true
      expect(normalizer.new(opts: {hide: false}).hide).to be false
      expect(normalizer.new(opts: {}).hide).to be_nil
    end

    it "returns saved :hide option" do
      norm = normalizer.new(opts: {hide: true})

      expect(norm.hide).to be true
      expect(norm.instance_variable_get(:@hide)).to be true

      norm.instance_variable_set(:@hide, nil)
      expect(norm.hide).to be_nil
    end

    context "with :lazy option" do
      subject(:hide) { normalizer.new(opts: {lazy: {use: :foo}}).hide }

      it "returns nil if `hide_lazy_attributes` setting is not set" do
        expect(hide).to be_nil
      end

      it "returns true if `hide_lazy_attributes` is set to true" do
        serializer_class.config.hide_lazy_attributes = true
        expect(hide).to be true
      end

      it "returns nil if `hide_lazy_attributes` is set to false" do
        serializer_class.config.hide_lazy_attributes = false
        expect(hide).to be_nil
      end
    end
  end

  describe "#serializer" do
    it "returns provided :serializer option" do
      expect(normalizer.new(opts: {serializer: 123}).serializer).to eq 123
    end

    it "returns saved :serializer option" do
      norm = normalizer.new(opts: {serializer: true})

      expect(norm.serializer).to be true
      expect(norm.instance_variable_get(:@serializer)).to be true

      norm.instance_variable_set(:@serializer, nil)
      expect(norm.serializer).to be_nil
    end
  end

  describe "#prepare_value_block" do
    it "returns provided block" do
      block = lambda { 123 }
      attribute = normalizer.new(block: block, opts: {})
      value_block = attribute.send(:prepare_value_block)
      expect(value_block).to equal block
    end

    it "returns provided value option" do
      value = lambda { |one, two| }
      attribute = normalizer.new(opts: {value: value})
      expect(attribute.send(:prepare_value_block)).to equal value
    end

    it "returns block generated by :method option" do
      block = normalizer.new(opts: {method: :length}).send(:prepare_value_block)
      expect(block).to be_a Proc
      expect(block.call(double(length: 3))).to eq 3
    end

    it "returns block generated by :const option" do
      const = "123"
      block = normalizer.new(opts: {const: const}).send(:prepare_value_block)
      expect(block).to be_a Proc
      expect(block.call).to be const
    end

    it "returns block generated by :delegate option when nil is not allowed" do
      object = double(foo: double(name: "DELEGATED_NAME"))
      delegate = {to: :foo}
      block = normalizer.new(name: :name, opts: {delegate: delegate}).send(:prepare_value_block)
      expect(block).to be_a Proc
      expect(block.call(object)).to eq "DELEGATED_NAME"
    end

    it "returns block generated by :delegate option that uses :method option" do
      object = double(foo: double(bar: "DELEGATED_NAME"))
      delegate = {to: :foo, method: :bar}
      block = normalizer.new(opts: {delegate: delegate}).send(:prepare_value_block)
      expect(block).to be_a Proc
      expect(block.call(object)).to eq "DELEGATED_NAME"
    end

    it "does not raise error when :delegating object is nil and nil is allowed" do
      object1 = double(foo: nil)
      object2 = double(foo: double(name: "NAME"))
      delegate = {to: :foo, allow_nil: true}
      block = normalizer.new(name: :name, opts: {delegate: delegate}).send(:prepare_value_block)
      expect(block).to be_a Proc
      expect(block.call(object1)).to be_nil
      expect(block.call(object2)).to eq "NAME"
    end

    it "does not raise error when :delegating object is nil and nil is allowed through config" do
      object1 = double(foo: nil)
      object2 = double(foo: double(name: "NAME"))
      delegate = {to: :foo}
      serializer_class.config.delegate_default_allow_nil = true
      block = normalizer.new(name: :name, opts: {delegate: delegate}).send(:prepare_value_block)
      expect(block).to be_a Proc
      expect(block.call(object1)).to be_nil
      expect(block.call(object2)).to eq "NAME"
    end
  end
end
